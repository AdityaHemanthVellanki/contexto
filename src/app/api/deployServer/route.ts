import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { authenticateRequest } from '@/lib/api-auth';
import { rateLimit } from '@/lib/rate-limiter-memory';
import { r2, R2_BUCKET } from '@/lib/r2';
import { GetObjectCommand } from '@aws-sdk/client-s3';
import { getStoreSpecificConfig, getVectorStoreApiKey, generateEmbedding } from '@/lib/vercel-deploy';
import fs from 'fs/promises';
import path from 'path';
import { initializeFirebaseAdmin } from '@/lib/firebase-admin-init';

// Initialize Firebase Admin SDK at module load time
// This ensures Firebase is ready before any requests are processed
try {
  // This will initialize Firebase Admin if not already initialized
  initializeFirebaseAdmin();
  console.log('✅ Firebase initialized successfully for deployServer API');
} catch (error) {
  console.error('❌ Firebase initialization failed in deployServer API:', 
    error instanceof Error ? error.message : String(error));
  // The error will be handled when the API route is called - no fallbacks
}

// Request schema validation
const DeployServerSchema = z.object({
  pipelineId: z.string().min(1)
});

// Render deployment file structure
interface RenderFile {
  file: string;
  data: string;
}

// Generate OpenAPI specification for the MCP server
function generateOpenAPISpec(pipelineId: string, purpose: string): string {
  return JSON.stringify({
    openapi: '3.0.0',
    info: {
      title: `MCP Server - ${pipelineId}`,
      description: `Model Context Protocol server for: ${purpose}`,
      version: '1.0.0'
    },
    servers: [
      {
        url: 'https://your-deployment-url.vercel.app',
        description: 'Production server'
      }
    ],
    paths: {
      '/mcp': {
        post: {
          summary: 'MCP Protocol Endpoint',
          description: 'Main endpoint for Model Context Protocol communication',
          requestBody: {
            required: true,
            content: {
              'application/json': {
                schema: {
                  type: 'object',
                  properties: {
                    method: { type: 'string' },
                    params: { type: 'object' }
                  }
                }
              }
            }
          },
          responses: {
            '200': {
              description: 'Successful response',
              content: {
                'application/json': {
                  schema: {
                    type: 'object',
                    properties: {
                      result: { type: 'object' }
                    }
                  }
                }
              }
            }
          }
        }
      },
      '/health': {
        get: {
          summary: 'Health check',
          responses: {
            '200': {
              description: 'Server is healthy'
            }
          }
        }
      }
    }
  }, null, 2);
}

// Generate MCP server function for Render deployment
function generateMCPServerFunction(pipelineId: string, vectorStoreEndpoint: string, storeType: string): string {
  return `import { NextRequest, NextResponse } from 'next/server';
import { initVectorStoreClient } from '../vectorStoreClient';

// MCP Server for Pipeline: ${pipelineId}
// Generated by Contexto

const PIPELINE_ID = '${pipelineId}';

// Initialize vector store from environment variables
const store = initVectorStoreClient({
  type: process.env.VECTOR_STORE_TYPE,
  config: JSON.parse(process.env.VECTOR_STORE_CONFIG || '{}')
});

// Log successful initialization
console.log(\`Vector store initialized: \${process.env.VECTOR_STORE_TYPE}\`);

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { method, params } = body;

    switch (method) {
      case 'tools/list':
        return NextResponse.json({
          tools: [
            {
              name: 'process_data',
              description: 'Process data through the MCP pipeline',
              inputSchema: {
                type: 'object',
                properties: {
                  input: {
                    type: 'string',
                    description: 'Input data to process'
                  },
                  options: {
                    type: 'object',
                    properties: {
                      topK: { type: 'number', default: 5 },
                      threshold: { type: 'number', default: 0.7 }
                    }
                  }
                },
                required: ['input']
              }
            },
            {
              name: 'get_pipeline_info',
              description: 'Get information about this MCP pipeline',
              inputSchema: {
                type: 'object',
                properties: {}
              }
            }
          ]
        });

      case 'tools/call':
        const { name, arguments: args } = params;
        
        if (name === 'process_data') {
          const { input, options = {} } = args;
          const { topK = 5 } = options;
          
          try {
            // Generate embeddings for the input
            // In a production environment, this would use a proper embeddings model
            const embedding = await generateEmbedding(input);
            
            // Query the vector store
            const results = await store.query(embedding, topK);
            
            // Process the results
            const context = results.map((result, i) => 
              \`[Context \${i+1}] \${result.metadata.text || 'No text available'}\`
            ).join('\\n\\n');
            
            return NextResponse.json({
              result: {
                processed: true,
                message: \`Processed input with \${results.length} context chunks\`,
                pipelineId: PIPELINE_ID,
                context: context,
                topMatches: results.length
              }
            });
          };

          return NextResponse.json({
            content: [
              {
                type: 'text',
                text: JSON.stringify(result, null, 2)
              }
            ]
          });
        }

        if (name === 'get_pipeline_info') {
          return NextResponse.json({
            content: [
              {
                type: 'text',
                text: JSON.stringify({
                  pipelineId: PIPELINE_ID,
                  vectorStore: {
                    type: STORE_TYPE,
                    endpoint: VECTOR_STORE_ENDPOINT
                  },
                  status: 'deployed',
                  version: '1.0.0'
                }, null, 2)
              }
            ]
          });
        }

        return NextResponse.json({
          error: { code: -32601, message: 'Method not found' }
        }, { status: 404 });

      default:
        return NextResponse.json({
          error: { code: -32601, message: 'Method not found' }
        }, { status: 404 });
    }
  } catch (error) {
    console.error('MCP Server error:', error);
    return NextResponse.json({
      error: { 
        code: -32603, 
        message: 'Internal error',
        data: error instanceof Error ? error.message : 'Unknown error'
      }
    }, { status: 500 });
  }
}

export async function GET() {
  return NextResponse.json({
    status: 'healthy',
    pipelineId: PIPELINE_ID,
    timestamp: new Date().toISOString()
  });
}
`;
}

// Deploy to Render.com using their API
async function deployToRender(pipelineId: string, downloadUrl: string, vectorStoreType: string, vectorStoreConfig: any): Promise<{ serviceUrl: string; serviceId: string }> {
  const renderToken = process.env.RENDER_TOKEN;
  const renderRegion = process.env.RENDER_REGION || 'iad';
  const renderPlan = process.env.RENDER_PLAN || 'free';

  if (!renderToken) {
    throw new Error('Render deployment credentials not configured. Please set RENDER_TOKEN environment variable.');
  }

  try {
    // Step 1: Create a new Render Web Service
    console.log(`Creating Render web service for pipeline: ${pipelineId}`);
    
    const createServicePayload = {
      type: 'web_service',
      name: pipelineId,
      region: renderRegion,
      plan: renderPlan,
      envVars: [
        // Azure OpenAI configuration
        { key: 'AZURE_OPENAI_API_KEY', value: process.env.AZURE_OPENAI_API_KEY || '', sync: false },
        { key: 'AZURE_OPENAI_ENDPOINT', value: process.env.AZURE_OPENAI_ENDPOINT || '', sync: false },
        { key: 'AZURE_OPENAI_DEPLOYMENT_EMBEDDING', value: process.env.AZURE_OPENAI_DEPLOYMENT_EMBEDDING || '', sync: false },
        { key: 'AZURE_OPENAI_DEPLOYMENT_TURBO', value: process.env.AZURE_OPENAI_DEPLOYMENT_TURBO || '', sync: false },
        // Vector store configuration
        { key: 'VECTOR_STORE_TYPE', value: vectorStoreType, sync: false },
        { key: 'VECTOR_STORE_CONFIG', value: JSON.stringify(vectorStoreConfig), sync: false },
        // Pipeline configuration
        { key: 'PIPELINE_ID', value: pipelineId, sync: false }
      ],
      serviceDetails: {
        type: 'docker',
        dockerfilePath: 'Dockerfile'
      },
      autoscale: false,
      instanceCount: 1
    };

    const createResponse = await fetch('https://api.render.com/v1/services', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${renderToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(createServicePayload)
    });

    if (!createResponse.ok) {
      const error = await createResponse.text();
      throw new Error(`Render service creation failed: ${error}`);
    }

    const serviceData = await createResponse.json();
    const serviceId = serviceData.id;
    const webServiceUrl = serviceData.webServiceUrl;
    
    console.log(`Created Render service: ${serviceId} at ${webServiceUrl}`);
    
    // Step 2: Trigger a manual deploy from the R2 ZIP
    console.log(`Triggering manual deploy for service: ${serviceId} from ZIP: ${downloadUrl}`);
    
    const deployPayload = {
      type: 'manual',
      tarballUrl: downloadUrl,
      rollBackOnFailure: true,
      clearCache: true
    };

    const deployResponse = await fetch(`https://api.render.com/v1/services/${serviceId}/deploys`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${renderToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(deployPayload)
    });

    if (!deployResponse.ok) {
      const error = await deployResponse.text();
      throw new Error(`Render manual deploy failed: ${error}`);
    }

    const deployData = await deployResponse.json();
    console.log(`Deploy initiated with ID: ${deployData.id}`);
    
    return {
      serviceUrl: webServiceUrl,
      serviceId: serviceId
    };

  } catch (error) {
    console.error('Render deployment error:', error);
    throw error;
  }
}

export async function POST(request: NextRequest) {
  try {
    // Apply rate limiting
    const rateLimitResult = await rateLimit(request, {
      limit: 3,
      windowSizeInSeconds: 600 // 3 requests per 10 minutes
    });

    if (rateLimitResult.limited) {
      return NextResponse.json(
        { error: 'Too many deployment requests. Please wait before trying again.' },
        { status: 429, headers: rateLimitResult.headers }
      );
    }

    // Authenticate request
    const authResult = await authenticateRequest(request);
    if (!authResult.authenticated) {
      return authResult.response || NextResponse.json({ error: 'Authentication failed' }, { status: 401 });
    }

    const userId = authResult.userId!;

    // Parse and validate request body
    const body = await request.json();
    const validationResult = DeployServerSchema.safeParse(body);
    
    if (!validationResult.success) {
      return NextResponse.json({
        error: 'Invalid request data',
        details: validationResult.error.issues
      }, { status: 400 });
    }

    const { pipelineId } = validationResult.data;

    // Load pipeline metadata
    const firestore = initializeFirebaseAdmin();
    const pipelineDoc = await firestore.collection('pipelines').doc(pipelineId).get();
    if (!pipelineDoc.exists) {
      return NextResponse.json({ error: 'Pipeline not found' }, { status: 404 });
    }

    const pipelineData = pipelineDoc.data()!;
    if (pipelineData.userId !== userId) {
      return NextResponse.json({ error: 'Unauthorized access to pipeline' }, { status: 403 });
    }

    // Check if vector store is deployed
    // Using the firestore instance we already initialized above
    const vectorStoreDoc = await firestore.collection('deployments').doc(`${userId}_${pipelineId}_vectorstore`).get();
    if (!vectorStoreDoc.exists) {
      return NextResponse.json({ 
        error: 'Vector store must be deployed first. Please deploy the vector store before deploying the server.' 
      }, { status: 400 });
    }

    const vectorStoreData = vectorStoreDoc.data()!;
    const vectorStoreEndpoint = vectorStoreData.endpoint;
    const storeType = vectorStoreData.storeType;

    // Check if server is already deployed
    // Using the firestore instance we already initialized above
    const existingDeployment = await firestore.collection('deployments').doc(`${userId}_${pipelineId}_server`).get();
    if (existingDeployment.exists) {
      const deploymentData = existingDeployment.data()!;
      if (deploymentData.status === 'deployed') {
        return NextResponse.json({
          mcpUrl: deploymentData.url,
          deploymentId: deploymentData.deploymentId,
          message: 'Server already deployed'
        });
      }
    }
    
    // Read the vectorStoreClient.js template
    let vectorStoreClientTemplate;
    try {
      vectorStoreClientTemplate = await fs.readFile(
        path.join(process.cwd(), 'src/templates/vectorStoreClient.js'), 
        'utf-8'
      );
      console.log('Successfully loaded vectorStoreClient.js template');
    } catch (error) {
      console.error('Failed to read vectorStoreClient.js template:', error);
      return NextResponse.json({ error: 'Failed to prepare deployment files' }, { status: 500 });
    }

    // Create a JSON config object for the vector store
    const vectorStoreConfig = {
      endpoint: vectorStoreEndpoint,
      apiKey: getVectorStoreApiKey(storeType),
      ...getStoreSpecificConfig(storeType, pipelineId, userId)
    };

    console.log(`Vector store config prepared for ${storeType}`);

    // Prepare deployment files
    const files: RenderFile[] = [
      {
        file: 'api/mcp.ts',
        data: generateMCPServerFunction(pipelineId, vectorStoreEndpoint, storeType)
      },
      {
        file: 'vectorStoreClient.js',
        data: vectorStoreClientTemplate
      },
      {
        file: 'package.json',
        data: JSON.stringify({
          name: `mcp-server-${pipelineId}`,
          version: '1.0.0',
          description: `MCP Server for pipeline ${pipelineId}`,
          main: 'api/mcp.ts',
          scripts: {
            build: 'tsc',
            start: 'node dist/api/mcp.js'
          },
          dependencies: {
            'next': '^14.0.0',
            '@types/node': '^20.0.0',
            'typescript': '^5.0.0'
          },
          engines: {
            node: '>=18.0.0'
          }
        }, null, 2)
      },
      {
        file: 'vercel.json',
        data: JSON.stringify({
          version: 2,
          functions: {
            'api/mcp.ts': {
              runtime: 'nodejs18.x'
            }
          },
          routes: [
            {
              src: '/mcp',
              dest: '/api/mcp'
            },
            {
              src: '/health',
              dest: '/api/mcp'
            }
          ]
        }, null, 2)
      },
      {
        file: 'openapi.yaml',
        data: generateOpenAPISpec(pipelineId, pipelineData.metadata?.purpose || 'MCP Pipeline')
      },
      {
        file: 'README.md',
        data: `# MCP Server - ${pipelineId}

This is an auto-deployed MCP (Model Context Protocol) server generated by Contexto.

## Endpoints

- \`POST /mcp\` - Main MCP protocol endpoint
- \`GET /health\` - Health check endpoint

## Usage

This server implements the MCP specification and can be used with any MCP-compatible client.

Vector Store: ${storeType}
Endpoint: ${vectorStoreEndpoint}

Generated on: ${new Date().toISOString()}
`
      }
    ];

    console.log(`Deploying MCP server for pipeline ${pipelineId} to Render.com...`);

    // First, get the pipeline export URL from R2
    // We need to call the export pipeline API to get the ZIP download URL
    const exportResponse = await fetch(`${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/api/exportMCP`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': request.headers.get('Authorization') || ''
      },
      body: JSON.stringify({ pipelineId })
    });

    if (!exportResponse.ok) {
      const error = await exportResponse.text();
      throw new Error(`Failed to export pipeline: ${error}`);
    }

    const exportData = await exportResponse.json();
    const downloadUrl = exportData.downloadUrl;

    if (!downloadUrl) {
      throw new Error('No download URL received from pipeline export');
    }

    console.log(`Using pipeline ZIP from: ${downloadUrl}`);

    // Deploy to Render.com
    const { serviceUrl, serviceId } = await deployToRender(pipelineId, downloadUrl, storeType, vectorStoreConfig);

    // Save deployment metadata
    // Using the firestore instance we already initialized above
    await firestore.collection('deployments').doc(`${userId}_${pipelineId}_server`).set({
      userId,
      pipelineId,
      type: 'server',
      url: serviceUrl,
      serviceId: serviceId,
      vectorStoreEndpoint,
      storeType,
      status: 'deployed',
      createdAt: new Date(),
      updatedAt: new Date()
    });

    // Log deployment
    // Using the firestore instance we already initialized above
    await firestore.collection('usage').add({
      userId,
      action: 'mcp_server_deployed',
      pipelineId,
      url: serviceUrl,
      serviceId: serviceId,
      timestamp: new Date()
    });

    return NextResponse.json({
      mcpUrl: serviceUrl,
      serviceId: serviceId,
      vectorStoreEndpoint,
      storeType,
      message: 'MCP server deployed successfully to Render.com'
    }, { 
      status: 200,
      headers: rateLimitResult.headers 
    });

  } catch (error) {
    console.error('MCP server deployment error:', error);
    return NextResponse.json({
      error: error instanceof Error ? error.message : 'Unknown deployment error'
    }, { status: 500 });
  }
}
