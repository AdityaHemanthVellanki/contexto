import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { getFirestoreAdmin } from '@/lib/firestore-admin';
import { authenticateRequest } from '@/lib/api-auth';
import { rateLimit } from '@/lib/rate-limiter-memory';
import { r2, R2_BUCKET } from '@/lib/r2';
import { GetObjectCommand } from '@aws-sdk/client-s3';
import { getStoreSpecificConfig, getVectorStoreApiKey, setVercelEnvironmentVariables, generateEmbedding } from '@/lib/vercel-deploy';
import fs from 'fs/promises';
import path from 'path';

// Request schema validation
const DeployServerSchema = z.object({
  pipelineId: z.string().min(1)
});

// Vercel deployment file structure
interface VercelFile {
  file: string;
  data: string;
}

// Generate OpenAPI specification for the MCP server
function generateOpenAPISpec(pipelineId: string, purpose: string): string {
  return JSON.stringify({
    openapi: '3.0.0',
    info: {
      title: `MCP Server - ${pipelineId}`,
      description: `Model Context Protocol server for: ${purpose}`,
      version: '1.0.0'
    },
    servers: [
      {
        url: 'https://your-deployment-url.vercel.app',
        description: 'Production server'
      }
    ],
    paths: {
      '/mcp': {
        post: {
          summary: 'MCP Protocol Endpoint',
          description: 'Main endpoint for Model Context Protocol communication',
          requestBody: {
            required: true,
            content: {
              'application/json': {
                schema: {
                  type: 'object',
                  properties: {
                    method: { type: 'string' },
                    params: { type: 'object' }
                  }
                }
              }
            }
          },
          responses: {
            '200': {
              description: 'Successful response',
              content: {
                'application/json': {
                  schema: {
                    type: 'object',
                    properties: {
                      result: { type: 'object' }
                    }
                  }
                }
              }
            }
          }
        }
      },
      '/health': {
        get: {
          summary: 'Health check',
          responses: {
            '200': {
              description: 'Server is healthy'
            }
          }
        }
      }
    }
  }, null, 2);
}

// Generate Vercel serverless function
function generateVercelFunction(pipelineId: string, vectorStoreEndpoint: string, storeType: string): string {
  return `import { NextRequest, NextResponse } from 'next/server';
import { initVectorStoreClient } from '../vectorStoreClient';

// MCP Server for Pipeline: ${pipelineId}
// Generated by Contexto

const PIPELINE_ID = '${pipelineId}';

// Initialize vector store from environment variables
const store = initVectorStoreClient({
  type: process.env.VECTOR_STORE_TYPE,
  config: JSON.parse(process.env.VECTOR_STORE_CONFIG || '{}')
});

// Log successful initialization
console.log(\`Vector store initialized: \${process.env.VECTOR_STORE_TYPE}\`);

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { method, params } = body;

    switch (method) {
      case 'tools/list':
        return NextResponse.json({
          tools: [
            {
              name: 'process_data',
              description: 'Process data through the MCP pipeline',
              inputSchema: {
                type: 'object',
                properties: {
                  input: {
                    type: 'string',
                    description: 'Input data to process'
                  },
                  options: {
                    type: 'object',
                    properties: {
                      topK: { type: 'number', default: 5 },
                      threshold: { type: 'number', default: 0.7 }
                    }
                  }
                },
                required: ['input']
              }
            },
            {
              name: 'get_pipeline_info',
              description: 'Get information about this MCP pipeline',
              inputSchema: {
                type: 'object',
                properties: {}
              }
            }
          ]
        });

      case 'tools/call':
        const { name, arguments: args } = params;
        
        if (name === 'process_data') {
          const { input, options = {} } = args;
          const { topK = 5 } = options;
          
          try {
            // Generate embeddings for the input
            // In a production environment, this would use a proper embeddings model
            const embedding = await generateEmbedding(input);
            
            // Query the vector store
            const results = await store.query(embedding, topK);
            
            // Process the results
            const context = results.map((result, i) => 
              \`[Context \${i+1}] \${result.metadata.text || 'No text available'}\`
            ).join('\\n\\n');
            
            return NextResponse.json({
              result: {
                processed: true,
                message: \`Processed input with \${results.length} context chunks\`,
                pipelineId: PIPELINE_ID,
                context: context,
                topMatches: results.length
              }
            });
          };

          return NextResponse.json({
            content: [
              {
                type: 'text',
                text: JSON.stringify(result, null, 2)
              }
            ]
          });
        }

        if (name === 'get_pipeline_info') {
          return NextResponse.json({
            content: [
              {
                type: 'text',
                text: JSON.stringify({
                  pipelineId: PIPELINE_ID,
                  vectorStore: {
                    type: STORE_TYPE,
                    endpoint: VECTOR_STORE_ENDPOINT
                  },
                  status: 'deployed',
                  version: '1.0.0'
                }, null, 2)
              }
            ]
          });
        }

        return NextResponse.json({
          error: { code: -32601, message: 'Method not found' }
        }, { status: 404 });

      default:
        return NextResponse.json({
          error: { code: -32601, message: 'Method not found' }
        }, { status: 404 });
    }
  } catch (error) {
    console.error('MCP Server error:', error);
    return NextResponse.json({
      error: { 
        code: -32603, 
        message: 'Internal error',
        data: error instanceof Error ? error.message : 'Unknown error'
      }
    }, { status: 500 });
  }
}

export async function GET() {
  return NextResponse.json({
    status: 'healthy',
    pipelineId: PIPELINE_ID,
    timestamp: new Date().toISOString()
  });
}
`;
}

// Deploy to Vercel using their API
async function deployToVercel(pipelineId: string, files: VercelFile[]): Promise<{ url: string; deploymentId: string }> {
  const vercelToken = process.env.VERCEL_TOKEN;
  const vercelOrgId = process.env.VERCEL_ORG_ID;
  const vercelProjectId = process.env.VERCEL_PROJECT_ID;

  if (!vercelToken || !vercelOrgId || !vercelProjectId) {
    throw new Error('Vercel deployment credentials not configured');
  }

  const deploymentName = `mcp-${pipelineId}`.toLowerCase().replace(/[^a-z0-9-]/g, '-');

  try {
    // Create deployment
    const deployResponse = await fetch('https://api.vercel.com/v13/deployments', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${vercelToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        name: deploymentName,
        // Removed projectId which was causing Vercel API error
        target: 'production',
        files: files.map(f => ({
          file: f.file,
          data: Buffer.from(f.data).toString('base64')
        })),
        functions: {
          'api/mcp.ts': {
            runtime: 'nodejs18.x'
          }
        }
      })
    });

    if (!deployResponse.ok) {
      const error = await deployResponse.text();
      throw new Error(`Vercel deployment failed: ${error}`);
    }

    const deployment = await deployResponse.json();
    const deploymentId = deployment.id;
    
    // Poll deployment status
    let attempts = 0;
    const maxAttempts = 30; // 5 minutes max
    
    while (attempts < maxAttempts) {
      const statusResponse = await fetch(`https://api.vercel.com/v13/deployments/${deploymentId}`, {
        headers: {
          'Authorization': `Bearer ${vercelToken}`
        }
      });

      if (statusResponse.ok) {
        const status = await statusResponse.json();
        
        if (status.readyState === 'READY') {
          return {
            url: `https://${status.url}`,
            deploymentId
          };
        }
        
        if (status.readyState === 'ERROR') {
          throw new Error(`Deployment failed: ${status.error?.message || 'Unknown error'}`);
        }
      }

      // Wait 10 seconds before next check
      await new Promise(resolve => setTimeout(resolve, 10000));
      attempts++;
    }

    throw new Error('Deployment timeout - please check Vercel dashboard');

  } catch (error) {
    console.error('Vercel deployment error:', error);
    throw error;
  }
}

export async function POST(request: NextRequest) {
  try {
    // Apply rate limiting
    const rateLimitResult = await rateLimit(request, {
      limit: 3,
      windowSizeInSeconds: 600 // 3 requests per 10 minutes
    });

    if (rateLimitResult.limited) {
      return NextResponse.json(
        { error: 'Too many deployment requests. Please wait before trying again.' },
        { status: 429, headers: rateLimitResult.headers }
      );
    }

    // Authenticate request
    const authResult = await authenticateRequest(request);
    if (!authResult.authenticated) {
      return authResult.response || NextResponse.json({ error: 'Authentication failed' }, { status: 401 });
    }

    const userId = authResult.userId!;

    // Parse and validate request body
    const body = await request.json();
    const validationResult = DeployServerSchema.safeParse(body);
    
    if (!validationResult.success) {
      return NextResponse.json({
        error: 'Invalid request data',
        details: validationResult.error.issues
      }, { status: 400 });
    }

    const { pipelineId } = validationResult.data;

    // Initialize Firestore
    const db = await getFirestoreAdmin();

    // Load pipeline metadata
    const pipelineDoc = await db.collection('pipelines').doc(pipelineId).get();
    if (!pipelineDoc.exists) {
      return NextResponse.json({ error: 'Pipeline not found' }, { status: 404 });
    }

    const pipelineData = pipelineDoc.data()!;
    if (pipelineData.userId !== userId) {
      return NextResponse.json({ error: 'Unauthorized access to pipeline' }, { status: 403 });
    }

    // Check if vector store is deployed
    const vectorStoreDoc = await db.collection('deployments').doc(`${userId}_${pipelineId}_vectorstore`).get();
    if (!vectorStoreDoc.exists) {
      return NextResponse.json({ 
        error: 'Vector store must be deployed first. Please deploy the vector store before deploying the server.' 
      }, { status: 400 });
    }

    const vectorStoreData = vectorStoreDoc.data()!;
    const vectorStoreEndpoint = vectorStoreData.endpoint;
    const storeType = vectorStoreData.storeType;

    // Check if server is already deployed
    const existingDeployment = await db.collection('deployments').doc(`${userId}_${pipelineId}_server`).get();
    if (existingDeployment.exists) {
      const deploymentData = existingDeployment.data()!;
      if (deploymentData.status === 'deployed') {
        return NextResponse.json({
          mcpUrl: deploymentData.url,
          deploymentId: deploymentData.deploymentId,
          message: 'Server already deployed'
        });
      }
    }
    
    // Read the vectorStoreClient.js template
    let vectorStoreClientTemplate;
    try {
      vectorStoreClientTemplate = await fs.readFile(
        path.join(process.cwd(), 'src/templates/vectorStoreClient.js'), 
        'utf-8'
      );
      console.log('Successfully loaded vectorStoreClient.js template');
    } catch (error) {
      console.error('Failed to read vectorStoreClient.js template:', error);
      return NextResponse.json({ error: 'Failed to prepare deployment files' }, { status: 500 });
    }

    // Create a JSON config object for the vector store
    const vectorStoreConfig = {
      endpoint: vectorStoreEndpoint,
      apiKey: getVectorStoreApiKey(storeType),
      ...getStoreSpecificConfig(storeType, pipelineId, userId)
    };

    console.log(`Vector store config prepared for ${storeType}`);

    // Prepare deployment files
    const files: VercelFile[] = [
      {
        file: 'api/mcp.ts',
        data: generateVercelFunction(pipelineId, vectorStoreEndpoint, storeType)
      },
      {
        file: 'vectorStoreClient.js',
        data: vectorStoreClientTemplate
      },
      {
        file: 'package.json',
        data: JSON.stringify({
          name: `mcp-server-${pipelineId}`,
          version: '1.0.0',
          description: `MCP Server for pipeline ${pipelineId}`,
          main: 'api/mcp.ts',
          scripts: {
            build: 'tsc',
            start: 'node dist/api/mcp.js'
          },
          dependencies: {
            'next': '^14.0.0',
            '@types/node': '^20.0.0',
            'typescript': '^5.0.0'
          },
          engines: {
            node: '>=18.0.0'
          }
        }, null, 2)
      },
      {
        file: 'vercel.json',
        data: JSON.stringify({
          version: 2,
          functions: {
            'api/mcp.ts': {
              runtime: 'nodejs18.x'
            }
          },
          routes: [
            {
              src: '/mcp',
              dest: '/api/mcp'
            },
            {
              src: '/health',
              dest: '/api/mcp'
            }
          ]
        }, null, 2)
      },
      {
        file: 'openapi.yaml',
        data: generateOpenAPISpec(pipelineId, pipelineData.metadata?.purpose || 'MCP Pipeline')
      },
      {
        file: 'README.md',
        data: `# MCP Server - ${pipelineId}

This is an auto-deployed MCP (Model Context Protocol) server generated by Contexto.

## Endpoints

- \`POST /mcp\` - Main MCP protocol endpoint
- \`GET /health\` - Health check endpoint

## Usage

This server implements the MCP specification and can be used with any MCP-compatible client.

Vector Store: ${storeType}
Endpoint: ${vectorStoreEndpoint}

Generated on: ${new Date().toISOString()}
`
      }
    ];

    console.log(`Deploying MCP server for pipeline ${pipelineId} to Vercel...`);

    // Deploy to Vercel
    const { url, deploymentId } = await deployToVercel(pipelineId, files);
    
    // Set environment variables for the deployment
    await setVercelEnvironmentVariables(deploymentId, {
      VECTOR_STORE_TYPE: storeType,
      VECTOR_STORE_CONFIG: JSON.stringify(vectorStoreConfig),
    });

    // Save deployment metadata
    await db.collection('deployments').doc(`${userId}_${pipelineId}_server`).set({
      userId,
      pipelineId,
      type: 'server',
      url,
      deploymentId,
      vectorStoreEndpoint,
      storeType,
      status: 'deployed',
      createdAt: new Date(),
      updatedAt: new Date()
    });

    // Log deployment
    await db.collection('usage').add({
      userId,
      action: 'mcp_server_deployed',
      pipelineId,
      url,
      deploymentId,
      timestamp: new Date()
    });

    return NextResponse.json({
      mcpUrl: url,
      deploymentId,
      vectorStoreEndpoint,
      storeType,
      message: 'MCP server deployed successfully'
    }, { 
      status: 200,
      headers: rateLimitResult.headers 
    });

  } catch (error) {
    console.error('MCP server deployment error:', error);
    return NextResponse.json({
      error: error instanceof Error ? error.message : 'Unknown deployment error'
    }, { status: 500 });
  }
}
